\frametitle {PIDA: Real World Example}
    \begin{block}{}
        Locate all functions within a binary that open a file and display the execution path from the entry point to the call of interest...
    \end{block}
    \begin{block}{}
    \begin{tiny}
    \begin{semiverbatim}
\emph{\textcolor{blue}{# for each function in the module}}
for function in module.functions.values():
    \emph{\textcolor{blue}{# create a downgraph from the current routine and locate the calls to [Open|Create]File[A|W]}}
    downgraph = module.graph\_down(function.ea\_start, -1)
    matches   = [node for node in downgraph.nodes.values() if re.match(".*(create|open)file.*", \\
                node.name, re.I)]
    upgraph   = pgraph.graph()

    \emph{\textcolor{blue}{# for each matching node create a temporary upgraph and add it to the parent upgraph.}}
    for node in matches:
        tmp\_graph = module.graph\_up(node.ea\_start, -1)
        upgraph.graph\_cat(tmp\_graph)

    \emph{\textcolor{blue}{# write the intersection of the down graph from the current function and the upgraph from}}
    \emph{\textcolor{blue}{# the discovered interested nodes to disk in gml format.}}
    downgraph.graph\_intersect(upgraph)

    if len(downgraph.nodes):
        fh = open("%s.gml" % function.name, "w+")
        fh.write(downgraph.render\_graph\_gml())
        fh.close()
    \end{semiverbatim}
    \end{tiny}
    \end{block}
    Together, PIDA and PyDbg offer a powerful combination for building a variety of tools. Consider for example the ease of re-creating Process Stalker on top of this platform.
